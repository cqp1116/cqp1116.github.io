<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>为什么用了索引还是慢</title>
    <link href="/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/"/>
    <url>/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、索引与慢查询"><a href="#一、索引与慢查询" class="headerlink" title="一、索引与慢查询"></a>一、索引与慢查询</h2><p>聊一聊索引和慢查询，经常遇到的一个问题：一个SQL语句使用了索引，为什么还是会记录到慢查询日志之中？<br>为了说明，创建一个表t，该表3个字段，一个主键索引，一个普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `a` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `b` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `a` (`a`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><img src="/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/bVc0dK8.png"></p><p>首先MySQL判断一个语句是不是慢查询语句，用的是语句执行时间，它把语句执行时间跟long_query_time这个系统参数做比较，如果语句执行时间比long_query_time还大，就会把这个语句记录到慢查询日志里。</p><p>long_query_time这个参数它的默认值是10s，在生产上我们不会设置这么大的值，一般会设置1s，对于一些对延迟比较敏感的业务，会设置一个比1还小的值，而对于语句是否使用了索引，它的意思是语句执行过程中有没有用到表的索引。<br><img src="/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/bVc0dK9.png"></p><p>具体到表象中是explain一个语句的时候，输出结果里面key的值不是NULL，图1就是执行 explain select <em>from t; 的结果。可以看到key这一列显示的是NULL。图2就是执行explain select</em> from t where id &#x3D; 2的结果，这里key显示的是PRIMARY，就是我们常说的使用了主键索引。图3就是执行select a from t 的结果，这里key这一列显示的是a，表示使用了a这个索引。可以看到图2和图3的结果里key的字段都不是NULL，而实际上图3是扫描了整个索引树a。</p><p>这个示例的表里面只有两行，那如果有100万行呢，有100万行的时候图2的语句还是可以执行很快，但是图3就肯定慢了，如果是更极端的情况，比如如果这个数据库上CPU压力非常地高，那可能第二个语句的执行时间也会超过long_query_time，会记录到慢查询日志里面，所以如果简单地回答这个问题，是否使用索引只是表示了一个SQL语句的执行过程，而是否记录到慢查询日志中是由它的执行时间决定的，而这个执行时间可能会受各种外部因素的影响，也就是说<strong>是否使用索引和是否记录慢查询之间没有必然的联系</strong>。</p><h2 id="二、索引的过滤性"><a href="#二、索引的过滤性" class="headerlink" title="二、索引的过滤性"></a>二、索引的过滤性</h2><p>如果我们再深层次的看这个问题其实它还潜藏着一个问题需要澄清就是，什么叫做使用了索引。我们知道InnoDB是索引组织表，所有的数据都是存储在索引树上面的，比如表t，这个表它包含了两个索引，一个主键索引一个普通索引a，在InnoDB里数据是放在主键索引里的。我们来看一下这个表的数据示意图，可以看到数据都放在主键索引上，如果从逻辑上说，所有的在InnoDB表上的查询，都至少用了一个索引，现在有一个问题：如果执行explain select * from t where id &gt; 0; 这个语句有用上索引吗？<br><img src="/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/bVc0dLb.png"><br><img src="/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/bVc0dLg.png"><br>现在我们来看看这个语句的explain的结果，在输出结果里，key这里显示的是PRIMARY，其实从数据上你是知道的这个语句一定是做了全表扫描，但是优化器认为，这个语句的执行过程中，需要根据主键索引定位到第一个满足id&gt;0的值，也算用到了索引。所以你看，即使explain结果里面写了key不是NULL，实际上也可能是全表扫描的，因此InnoDB里面只有一种情况叫做没有使用索引，那就是从主键索引的最左边的叶节点开始，向右扫描整个索引树，也就是说，没有使用索引并不是一个准确的描述，你可以用<strong>全表扫描</strong>来表示一个查询遍历了整个主键索引树。也可以用全索引扫描来说明，像select a from t这样的查询，它扫描了整个普通索引树。而像select * from t where id &#x3D; 2; 这样的语句才是我们平时说的使用了索引，它表示的意思是我们使用了索引的快速搜索功能，并且有效的减少了扫描行数。</p><p>那么除了全索引扫描，还有哪些是使用了索引但是执行速度不够快的例子呢，这就要说到<strong>索引的过滤性</strong>，假设你现在维护了一个表，这个表记录了全中国人的基本信息，然后你现在要查出年龄在10到15岁之间的小朋友的姓名和基本信息，那么你的语句会这么写，select <em>from t_people where age between 10 and 15;你一看这个语句一定要在age字段上建索引了，否则就是个全表扫描。但是你会发现在age上建了索引以后，这个语句还是执行慢，因为满足这个条件的数据有超过1亿行。我们来看看建立了这个索引以后这个表的组织结构图，这个语句的执行流程是这样的。从索引age上用树搜索，取到第一个age等于10的记录，得到它的主键ID的值，根据ID的值去主键索引取整行的信息，作为结果集的一部分返回，在索引age上向右扫描，取下一个ID值，到主键索引上取整行信息，作为结果集的一部分返回，重复上面的步骤直到碰到第一个age&gt;15的记录。你看这个语句，虽然它用了索引，但是它扫描超过了一亿行，而上面select</em> from t;这个语句虽然没有用索引，但其实也只扫描了两行。<br><img src="/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/bVc0dLj.png"></p><p>所以你现在知道了，当我们讨论有没有使用索引的时候，其实我们关心的是扫描行数，对于一个大表，不止要有索引，索引的过滤性还要足够好，像刚才这个例子age这个索引它的过滤性就不够好。在设计表结构的时候，我们要让索引的过滤性足够好，也就是区分度足够高。那么过滤性好了，是不是表示查询的扫描行数就一定少呢，我们再来看一个例子。</p><h2 id="三、索引的扫描行数"><a href="#三、索引的扫描行数" class="headerlink" title="三、索引的扫描行数"></a>三、索引的扫描行数</h2><p><img src="/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/bVc0dLl.png"><br>如果这个t_people表上有一个索引是姓名、年龄的联合索引，那这个联合索引的过滤性应该不错，如果你的执行语句是select <em>from t_people where name &#x3D; ‘张三’ and age &#x3D; 8; 就可以在一个索引上快速找到第一个姓名是张三并且年龄是8岁的小朋友，当然这样的小朋友就该不多，因此向右扫描的行数很少，查询效率就很高，但是查询的过滤性和索引的过滤性可并不一定是一样的。如果现在你的需求是查出所有名字第一个字是张并且年龄是8岁的所有小朋友，你的语句会怎么写呢？你的语句要这么写：select</em> from t_people where name like ‘张%’ and age &#x3D; 8; 在MySQL5.5和之前的版本中，这个语句的执行流程是这样的。首先从联合索引树上找到第一个姓名字段是张开头的记录，取出主键ID，然后到主键索引上，根据ID取出整行的值，判断年龄字段是否等于8如果是就作为结果集的一行返回，如果不是就丢弃，我们把根据ID到主键索引上查找整行数据这个动作称为<strong>回表</strong>，在联合索引上向右遍历，并重复做回表和判断的逻辑直到碰到联合索引树上名字第一个字不是张的记录为止。你可以看到这个执行过程里面最耗费时间的步骤就是回表，假设全国名字第一个字是张的人有8000万，那么这个过程就要回表8000万次，在定位第一行记录的时候，只能使用索引和联合索引的最左前缀，称为最左前缀原则。那你可以看到这个执行过程它的回表次数特别多，性能不够好，那有没有优化的方法呢？有的在MySQL5.6版本引入了index condition pushdown的优化，我们来看看这个优化的执行流程。</p><p>首先从联合索引树上找到第一个姓名字段是张开头的记录，判断这个索引记录里面年龄的值是不是8，如果是就回表，取出整行数据作为结果集的一部分返回，如果不是就丢弃。在联合索引树上向右遍历，并判断年龄字段后根据需要做回表，直到碰到联合索引树上名字的第一个字不是张的记录为止。这个过程跟上面过程的差别是在遍历联合索引的过程中，将年龄等于8这个条件下推到索引遍历的过程中，减少了回表的次数，假设全国名字第一个字是张的人里面朋100万个是8岁的小朋友，那么这个查询过程中，在联合索引里要遍历8000万次，而回表只需要100万次。可以看到，index condition pushdown 优化的效果还是很不错的，但是这个优化，还是没有绕开最左前缀原则的限制，因此在联合索引里，还是要扫描8000万行，那有没有更进一下的优化方法呢？我们可以把名字的第一个字，和年龄做一个联合索引来试试，这里可以用到MySQL 5.7引入的虚拟列来实现，对应的修改表结构的SQL语句是这么写的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_people <span class="hljs-keyword">add</span> name_first <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>) generated always <span class="hljs-keyword">as</span> <br>(<span class="hljs-keyword">left</span>(name, <span class="hljs-number">1</span>)), <span class="hljs-keyword">add</span> index (name_first, age);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_people` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `info` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `name_first` <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>) GENERATED ALWAYS <span class="hljs-keyword">AS</span> (<span class="hljs-keyword">left</span>(`name`, <span class="hljs-number">1</span>)) VIRTUAL,<br>  KEY `name_first` (`name_first`, `age`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p><img src="/2022/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E6%85%A2/bVc0dLn.png"><br>&#x3D;&#x3D;上图是这个DDL语句的执行效果，首先它在t_people上创建一个字段叫name_first虚拟列，然后给name_first和age上创建一个联合索引，并且让这个虚拟列的值，总是等于name字段的前两个字节，虚拟列在插入数据的时候，不能指定值，在更新的时候也不能指定修改，它的值会根据定义自动生成，在name字段修改的时候，也会自动修改，有了这个新的联合索引，我们再找名字第一个字是张并且年龄是8的小朋友的时候，这个SQL语句就可以这么写：select * from t_people where name_fist &#x3D; ‘张’ and age &#x3D; 8; 这样这个语句的执行过程，就只需要扫描联合索引的100万行并回表100万次。这个优化的本质是创建了一个更紧凑的索引来加速了查询的过程。&#x3D;&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务架构与演进</title>
    <link href="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/"/>
    <url>/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务架构与演进"><a href="#微服务架构与演进" class="headerlink" title="微服务架构与演进"></a>微服务架构与演进</h1><p><strong>微服务（Microservices）是一种软件架构风格。</strong>它以职责单一、细粒度的小型功能模块为基础，并将这些小型功能模块组合成一个复杂的大型系统。</p><p>软件开发在短短十余年发生了深刻的变革，以 Docker 为代表的容器技术比传统的虚拟机更轻量，消耗的系统资源更少。同时，通过 Dockefile 等配置文件，我们不仅可以定义服务构建规则、启动参数等，还能够定义服务所需的环境依赖。我们也可以保证一个容器重建后可以和之前的容器有相同的环境和行为。这极大地降低了开发以及服务部署、运维的成本，让部署更多的原子服务成为了可能。</p><p>当前的大型互联网公司，业务规模和流量日渐增长，整个服务集群规模也越来越大，但是服务却拆分得越来越细。所以这节课，我们就来拆解一下，在构建微服务架构的过程中，我们面临的挑战以及需要具备的技术，让你对于微服务架构有更深入的理解。</p><h5 id="单体服务-VS-微服务"><a href="#单体服务-VS-微服务" class="headerlink" title="单体服务 VS 微服务"></a>单体服务 VS 微服务</h5><p>企业的系统架构通常是由业务驱动的，小企业或新的产品线在业务刚刚起步阶段，代码少、功能也简单，这时我们一般会把所有功能打包到同一个服务中，使用单体服务具有较高的开发效率。</p><p>但是，系统的架构也需要与时俱进。随着访问量逐渐变大、业务模式越来越复杂，相似的功能开始组建起一个模块，模块与模块之间需要相互调用。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/ed70915fyyec34f2f5960f233yyd2017.jpg"></p><p>除了按照功能划分模块，我们也可以按照逻辑对模块进行划分。例如，比较经典的分层设计模式是在桌面程序和 Web 服务中使用广泛的 MVC 架构。MVC 将架构分为了视图层（View）、控制层（Controller）和模型（Model）层。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/954e944dcf718b191848c0aa6131ae9f.jpg"></p><p>分层的架构能够提供统一的开发模式，开发者容易理解。同时，模块间的解耦导致了关注点分离，避免了因为业务和开发人员越来越多导致的混乱。此外，上层和业务功能相关的代码一般更容易发生变动，而偏技术的底层代码（如操作数据库）改动较小，这使得底层代码更容易复用。</p><p>业务进一步复杂之后，分层架构的模式也逐渐带来了弊病。由于使用分层架构意味着添加或更改业务功能几乎会涉及到所有层级，这样一来，要修改单个功能就变得非常麻烦了。我们分的层级越多，这个问题就越严重。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/34yyf7fed5d12e8399b1a1d2e0b42566.jpg"></p><p>为了解决分层架构的问题，我们会选择在分层的基础上，按照业务功能做拆分，将各分层贯穿起来，这被称为垂直切片（Vertical slice），如下图。分离出模块还有一个附加的好处，那就是模块可以简单复用到其他的单体服务中。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/4891fef4a7050f86c17545e7807b9a9d.jpg"></p><p>模块与模块之间为了实现低耦合，需要定义明确的接口进行通信。接口应该具有稳定性，职责清晰，并且能够隐藏模块内部的实现细节。</p><p>接口可以采取多种不同的实现形式。同步的方式包括，调用另一个组件库中的公共函数（在 Go 中为首字母大写的方法或函数）；也可能是通过异步的方式，例如通过中间件发布与订阅，或者通过共享文件、数据库的方式进行通信。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/3797cc2a073e13d1a9b0f48911d9210c.jpg"></p><p>上述的单体服务在项目初期能够提供比较高的开发效率。但随着业务复杂度进一步上升，系统的复杂度通常会呈指数型上升，主要原因有下面几个。</p><ul><li>与最初设计偏离</li></ul><p>随着系统越来越大，参与的人员变得越来越多，由于每一个开发者都有自己的开发风格（有的喜欢在 View 层随意加入更多的逻辑，有的为了赶项目加入了临时的解决方案），久而久之，代码的逻辑分支变得越来越多，学习维护成本大大增加。</p><ul><li>模块耦合</li></ul><p>低耦合的模块化设计失效，不仅模块内代码耦合，模块与模块之间的依赖关系也错综复杂。通常一处修改会有牵一发而动全身的效果，开发越来越容易犯错。如果你负责的是团队的核心业务，例如订单与收银，维护屎山代码常常会背负着比较大的精神压力。</p><ul><li>团队管理、开发效率变低</li></ul><p>经典项目管理书籍《人月神话》中曾提到，简单地增加开发人员并不会缩短项目的开发周期，甚至可能起到负面作用。现在推崇的小团队开发模式一般由 6-8 个人组成，它可以保证团队之间高效协作。</p><p>与此同时，随着业务日益复杂化，如果众多团队挤在同一个单体服务中，甚至可能出现排队上线的情况，不利于敏捷开发。因此，当服务进一步膨胀时，我们通常就需要将服务拆分为职责单一、功能细粒度的微服务。微服务是方法而不是目标，只有当前架构无法实现我们的最终目标时，才有必要考虑迁移到微服务架构。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/1acb215567dd757753e1ba10e1bef80e.jpg"></p><p>说了这么多，那微服务架构是如何解决上述问题的呢？这离不开微服务自身具备的特性。接下来，我们就来聊一聊微服务的优势，也看看使用微服务需要承担的代价。</p><h5 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h5><p>微服务主要有下面几个方面的优势。</p><ul><li>技术异质性</li></ul><p>对于单体应用程序，如果我们想尝试一种新的编程语言、数据库或框架，或者是对技术进行升级，任何更改都可能影响整个系统，风险巨大。而使用了微服务架构之后，就可以在风险最低的微服务中使用这门技术，让团队更快地接纳和吸收新技术。</p><p>同时，不同团队也可以根据问题的特点使用相对应的技术。例如前端服务使用 React，后端 Web 服务使用 Go，模型训练服务使用 C++。</p><ul><li>稳健性</li></ul><p>如果使用微服务架构，系统的一个组件发生故障，只要该故障没有级联，你就可以隔离问题，确保系统的其余部分继续工作。但是在单体服务中，如果服务崩溃，一切都会停止工作。</p><ul><li>更易扩容、更灵活</li></ul><p>当系统由于请求量上涨等因素导致承载能力不足时，我们还需要对服务进行扩容。单体服务由于服务内各模块都是聚合在一起的，扩容时也必须各模块同时进行扩容。然而每一个模块的需求和承载能力未必相同。例如订单服务会被系统中更多的功能调用，需要承担更多的流量。同时扩容就容易造成资源的浪费。而微服务架构则可以根据服务的承载能力对不同服务进行不同程度的扩容。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/87396c3e248d1c9441ebdb4ca7974f65.jpg"></p><ul><li>团队效率更高</li></ul><p>小团队往往更有效率。微服务架构能够更好地与我们的组织架构保持一致。</p><ul><li>可组合性</li></ul><p>单一功能的服务之间，通过简单的排列组合很容易灵活地构建出另一个系统。这对于代码复用、系统重构、以及快速构建新的系统都有很大帮助。</p><p>然而，微服务并不是银弹，在享受微服务好处的同时，我们也遇到了新的难题。</p><h5 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h5><p>微服务主要面临下面这些问题。</p><ul><li>服务太多，难以开发调试</li></ul><p>当我们开发服务 A 的一个功能时，如果服务 A 调用了服务 B，服务 B 调用了服务 C，而我们的操作依赖于服务 C 返回的数据，那么就需要在本地将服务 A、服务 B、服务 C 都启动起来，并且还要想办法配置正确，让服务 A 能够正确调用本地的服务 B，这个过程是非常繁琐的。</p><p>对于线上的服务，由于调用链太长，我们也很难快速定位出现问题的服务是哪一个。服务的测试和调试难度也相应地变大了。</p><ul><li>延迟增加</li></ul><p>以前，我们只需要处理单个进程中共享的信息，现在则需要对信息进行序列化、传输和反序列化，这增加了处理时间。另外，如果服务器不能正确地处理大量的网络连接，也可能导致系统延迟恶化。</p><ul><li>日志聚合与监控</li></ul><p>系统的日志分散在各处，检索和调试都将变得非常困难，因此，需要有新的手段能够将分布式的日志聚合起来。同时，我们对系统的监控也开始变得困难，亟需单独的工具和手段对分布式系统进行统一管理，帮助我们记录并识别当前系统面临的问题。</p><p>除了上面介绍的问题，微服务还面临着分布式系统具有的固有挑战：数据一致性、可用性、安全等问题。</p><p>在设计或者将业务迁移到微服务的过程中，还有一个重要的问题是微服务的边界在哪里。</p><h5 id="微服务的边界"><a href="#微服务的边界" class="headerlink" title="微服务的边界"></a>微服务的边界</h5><p>一般来说，我们设计微服务架构的目的是方便更高效地修改业务功能。在设计业务架构时，优先考虑的是业务功能的高内聚性，我们希望将相似的业务功能聚合在同一个微服务中，并由一个小团队进行开发维护。</p><p>与此同时呢，微服务的边界并不能用服务的代码量大小来衡量，因为不同语言的代码量大小都会有所不同。微服务应该是一个足够独立的模块，这样我们才能更容易对大量的微服务进行组合，构建起更大规模的系统。</p><p>因此，设计微服务边界时重要的原则就是高内聚、低耦合。</p><ul><li>高内聚</li></ul><p>对高内聚比较有表现力的描述是：“一起改变的代码，放置在一起”。将功能相关的代码聚合到一起，能够帮助我们在尽可能少的地方做修改。例如，把和用户权益相关的功能整合在一起，当我们需要频繁变更部署用户权益系统时，就不用改动也不用重新部署其他服务了。</p><ul><li>低耦合</li></ul><p>高内聚强调的是微服务内部的关系，而低耦合强调的是服务与服务之间的关系。在微服务架构中，服务与服务之间的关系应该是松散、低耦合的。什么样的情况可能出现服务紧密耦合呢？举个例子，如果我们要对权益系统进行修改，就必须同时修改上游和下游服务。</p><p>高内聚与低耦合是一体两面的，更好地实现内聚也将降低服务间的耦合度，而低耦合同样也取决于服务与服务之间的沟通模式。对外提供的 API 应该更可能少，隐藏内部的实现细节，同时 API 提供向后兼容的能力。其他服务不需要知道当前服务内部实现的细节，将当前服务当做一个黑盒。这种服务关注点的分离，能够让我们驾驭更大规模的程序。</p><h5 id="微服务的通信"><a href="#微服务的通信" class="headerlink" title="微服务的通信"></a>微服务的通信</h5><p>当我们定义了服务的边界，完成了服务的拆分，另一个重要的问题就是如何将服务组合起来，实现更大的系统了，这涉及到服务之间的通信。</p><p><strong>微服务之间的通信从大的方向来看分为了两种，一种是同步通信，一种是异步通信。</strong></p><p>同步的方式堵塞等待服务器的返回，例如，在数据库上运行 SQL 查询，或者向下游 API 发出 HTTP 请求。这是一种最简单直接的方式。这种情况如果下游响应缓慢，或者高峰期处理不过来，会反过来影响上游服务的耗时。</p><p><strong>另一些情况下，我们需要使用异步通信，异步通信可以通过回调、事件驱动和数据共享的方式实现。</strong>例如，一些数据分析操作需要执行非常长的时间才会有结果，这时我们可以让下游服务简单地返回，等结果出来之后再以回调的方式通知上游。</p><p><strong>异步请求的另一种方式是事件驱动的通信。</strong>相较于上游服务主动通知下游服务，事件驱动的通信将处理数据的责任交给了下游服务。举一个例子，服务 A 检测到用户异常登陆之后，可以往消息中间件中发送消息。但是，上游服务不需要知道下游哪一个服务需要这条消息。这条消息可能会被服务 B 消费，用于给用户发送邮件和短信提示；也可能被风控部门获取，用于分析异常用户的行为。这样，服务间的关系就变得更加松散解耦了。</p><p><strong>最后一种比较特殊的异步通信是借助共享的数据库或者文件进行通信。</strong>例如，我们可以有一个数据推送服务 A，将运营在页面修改后的数据推送到各台机器的指定位置，而服务 B 会定时地检查当前配置文件是否发生了变更，如果发生了变更就将新的配置加载到内存中。再比如，数据库也可以进行通信，甚至进行分布式的协调。这种借助共享数据的通信是一种简单直接的方式。</p><p>不过，由于下游一般采取轮询的方式检查变更，这种方式很难在对延迟要求比较低的场景使用。还有一点需要注意，那就是公共数据可能会让服务耦合，如果公共数据结构发生变化，通常下游服务也需要进行相应的调整。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/af3068a086ae2b4d9df4f4788639ce5e.jpg"></p><p>另外，微服务通信时还涉及到通信协议和消息中间件的选型，例如同步协议应该使用 HTTP、GRPC 还是 Thrift 协议，消息中间件应该选择 Kafka、RabbitMQ、还是 Pulsar，甚至包括了序列化数据的方式应该选择 JSON 还是 Protobuf。在后面的项目课程中我们将会详细分析。</p><h5 id="服务发现与负载均衡"><a href="#服务发现与负载均衡" class="headerlink" title="服务发现与负载均衡"></a>服务发现与负载均衡</h5><p>传统的应用程序，其依赖的下游服务的网络位置通常是固定的，网络地址可以直接配置在服务的配置文件中。但是，微服务架构中，服务众多，服务可以动态地进行扩容与销毁，服务的地址也是动态分配的。因此，我们需要有更灵活的服务发现机制，以便知道当前环境中运行着哪些服务。</p><p>服务发现通常包含了两个部分，第一部分涉及服务的注册，即在服务启动时告诉服务注册中心：“我在这里！”，并通过定时的心跳连接保持服务的存活状态。第二部分为服务的发现，调用者通过服务注册中心获取服务的可用节点列表。</p><p>在实践中，有多种服务发现的形式，最基本的两种形式为服务端发现模式与客户端发现模式。</p><p>服务端发现模式在调用方与被调用方之间额外增加了代理网关层，代理网关接到请求后，从服务注册中心获取指定服务可用的节点列表，并且根据相应的负载均衡策略选择一个最终的节点进行访问。开源的 HAproxy、Nginx 等负载均衡器产品都可以作为代理模式的网关服务。</p><p>服务端发现模式的优点是服务调用方不用关注发现的细节，服务和监控等策略可以统一在代理网关进行。但是服务端发现模式的缺点是网络中多了一层，部署相对复杂，并且本身容易变成新的单点故障和性能瓶颈。</p><p>K8s 的 Service 资源实现服务发现本质上就是一种服务端的服务发现模式，但是它实现的方式却有很大不同。Service 会生成一个虚拟的 IP，通过修改 iptables 规则的方式，将虚拟的 IP 转发到指定 Pod 的地址中，实现服务发现与负载均衡的功能。在课程后期，我们还会详细介绍 K8s 相关的知识。</p><p>另一种服务发现模式为客户端发现模式。和服务端发现模式不同的是，客户端发现模式能够直接从服务注册中心获取可用的节点列表，并可以监听服务节点注册的变化。调用方集成的 SDK 能够根据一定的负载均衡策略选定一个最终的服务节点。</p><p><img src="/2022/11/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BC%94%E8%BF%9B/acd4ba55c39801fa83d59cf680yy223d.jpg"></p><p>那这两种服务发现模式，选哪种更好呢？其实，根据实际的场景，我们可以选择不同的服务发现模式和对应的负载均衡策略。有些大型互联网公司可能会同时使用两种模式，并把它们混合起来。例如，服务调用方利用 SDK 从服务注册中心获得的是虚拟 IP（virtual IP address  ，VIP），然后借助 LVS、Nginx 等技术完成负载均衡。典型的服务注册中心 etcd、ZooKeeper、Consul 我们还会在后面的详细介绍。</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
